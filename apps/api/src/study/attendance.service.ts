import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, In, Between } from 'typeorm';
import { Cron, CronExpression } from '@nestjs/schedule';
import {
  StudyGroup,
  StudyMember,
  AttendanceRecord,
  VacationRequest,
  User,
  UserStats,
} from '@pnu-blace/db';
import { 
  AttendanceStatus, 
  MemberAttendanceHistoryRequest, 
  MemberAttendanceHistoryResponse,
  AttendanceRecordDetail,
  AttendanceStats
} from '@pnu-blace/types';
import { SchoolApiService } from '../school-api/school-api.service';

interface LibraryUsageRecord {
  useDt: string; // "YYYY.MM.DD"
  startTm: string; // "HH:MM"
  endTm: string; // "HH:MM"
  roomNm: string;
}

@Injectable()
export class AttendanceService {
  private readonly logger = new Logger(AttendanceService.name);

  constructor(
    @InjectRepository(StudyGroup)
    private studyGroupRepository: Repository<StudyGroup>,
    @InjectRepository(StudyMember)
    private studyMemberRepository: Repository<StudyMember>,
    @InjectRepository(AttendanceRecord)
    private attendanceRecordRepository: Repository<AttendanceRecord>,
    @InjectRepository(VacationRequest)
    private vacationRequestRepository: Repository<VacationRequest>,
    @InjectRepository(User)
    private userRepository: Repository<User>,
    @InjectRepository(UserStats)
    private userStatsRepository: Repository<UserStats>,
    private schoolApiService: SchoolApiService,
  ) {}

  /**
   * 30분마다 출퇴근 동기화 실행
   */
  @Cron(CronExpression.EVERY_30_MINUTES)
  async syncAllAttendance(): Promise<void> {
    this.logger.log('Starting attendance sync for all study groups...');

    try {
      const activeGroups = await this.studyGroupRepository.find();

      for (const group of activeGroups) {
        await this.syncGroupAttendance(group.groupId);
      }

      this.logger.log('Attendance sync completed for all groups');
    } catch (error: any) {
      this.logger.error(`Attendance sync failed: ${error.message}`);
    }
  }

  /**
   * 특정 스터디 그룹의 출퇴근 동기화
   */
  async syncGroupAttendance(groupId: string): Promise<void> {
    this.logger.debug(`Syncing attendance for group: ${groupId}`);

    const group = await this.studyGroupRepository.findOne({
      where: { groupId },
    });

    if (!group) {
      this.logger.warn(`Group not found: ${groupId}`);
      return;
    }

    // 오늘이 운영일인지 확인
    const today = new Date();
    const dayOfWeek = today.getDay() || 7; // 일요일을 7로 변환

    if (!group.operatingDays.includes(dayOfWeek.toString())) {
      this.logger.debug(`Today is not an operating day for group: ${groupId}`);
      return;
    }

    // 멤버 목록 조회
    const members = await this.studyMemberRepository.find({
      where: { groupId },
    });

    for (const member of members) {
      await this.syncMemberAttendance(group, member, today);
    }
  }

  /**
   * 특정 멤버의 출퇴근 동기화
   */
  private async syncMemberAttendance(
    group: StudyGroup,
    member: StudyMember,
    date: Date,
  ): Promise<void> {
    try {
      // 사용자 정보 조회
      const user = await this.userRepository.findOne({
        where: { studentId: member.studentId },
      });

      if (!user || !user.schoolSessionId) {
        this.logger.debug(`No session for user: ${member.studentId}, skipping`);
        return;
      }

      // 휴가 확인
      const isOnVacation = await this.checkVacation(
        group.groupId,
        member.studentId,
        date,
      );

      if (isOnVacation) {
        await this.upsertAttendanceRecord(
          group.groupId,
          member.studentId,
          date,
          {
            status: 'VACATION',
            isAutoGenerated: true,
          },
        );
        return;
      }

      // 도서관 이용 기록 조회
      const libraryRecords = await this.schoolApiService.getMySeatHistory(
        member.studentId,
        user.schoolSessionId,
      );

      // 오늘 날짜 기록만 필터링
      const todayStr = this.formatDateForCompare(date);
      const todayRecords = libraryRecords.filter(
        (record: LibraryUsageRecord) => record.useDt === todayStr,
      );

      if (todayRecords.length === 0) {
        // 기록 없음 - 아직 출근 안함 (결석 처리는 자정에)
        return;
      }

      // 첫 입실 시간, 마지막 퇴실 시간 계산
      const checkInTime = this.getEarliestTime(todayRecords, 'startTm');
      const checkOutTime = this.getLatestTime(todayRecords, 'endTm');

      // 총 이용 시간 계산
      const usageMinutes = this.calculateTotalUsageMinutes(todayRecords);

      // 출퇴근 상태 판별
      const status = this.determineAttendanceStatus(
        group,
        checkInTime,
        checkOutTime,
        usageMinutes,
      );

      // 출퇴근 기록 저장/업데이트
      await this.upsertAttendanceRecord(group.groupId, member.studentId, date, {
        checkInTime,
        checkOutTime,
        status,
        usageMinutes,
        isAutoGenerated: true,
      });

      // 연속성 업데이트
      await this.updateStreakStats(group.groupId, member.studentId, date, status);

      this.logger.debug(
        `Updated attendance for ${member.studentId}: ${status}`,
      );
    } catch (error: any) {
      this.logger.error(
        `Failed to sync attendance for ${member.studentId}: ${error.message}`,
      );
    }
  }

  /**
   * 출퇴근 상태 판별
   */
  private determineAttendanceStatus(
    group: StudyGroup,
    checkInTime: string,
    checkOutTime: string | null,
    usageMinutes: number,
  ): AttendanceStatus {
    const checkInMinutes = this.timeToMinutes(checkInTime);
    const checkInEndMinutes = this.timeToMinutes(group.checkInEndTime);
    const checkOutMinMinutes = this.timeToMinutes(group.checkOutMinTime);

    // 지각 체크: 출근 마감 시간 이후 입실
    const isLate = checkInMinutes > checkInEndMinutes;

    // 조퇴 체크: 퇴근 시간 전 퇴실 또는 최소 이용시간 미달
    let isEarlyLeave = false;
    if (checkOutTime) {
      const checkOutMinutes = this.timeToMinutes(checkOutTime);
      isEarlyLeave =
        checkOutMinutes < checkOutMinMinutes ||
        usageMinutes < group.minUsageMinutes;
    }

    // 상태 결정
    if (isLate && isEarlyLeave) {
      return 'LATE'; // 지각 우선
    } else if (isLate) {
      return 'LATE';
    } else if (isEarlyLeave) {
      return 'EARLY_LEAVE';
    }

    return 'PRESENT';
  }

  /**
   * 출퇴근 기록 upsert
   */
  private async upsertAttendanceRecord(
    groupId: string,
    studentId: string,
    date: Date,
    data: Partial<AttendanceRecord>,
  ): Promise<void> {
    const dateOnly = new Date(date);
    dateOnly.setHours(0, 0, 0, 0);

    const existing = await this.attendanceRecordRepository.findOne({
      where: {
        groupId,
        studentId,
        date: dateOnly,
      },
    });

    if (existing) {
      await this.attendanceRecordRepository.update(
        { recordId: existing.recordId },
        data,
      );
    } else {
      const record = this.attendanceRecordRepository.create({
        groupId,
        studentId,
        date: dateOnly,
        ...data,
      });
      await this.attendanceRecordRepository.save(record);
    }
  }

  /**
   * 휴가 확인
   */
  private async checkVacation(
    groupId: string,
    studentId: string,
    date: Date,
  ): Promise<boolean> {
    const vacation = await this.vacationRequestRepository.findOne({
      where: {
        groupId,
        studentId,
        status: 'APPROVED',
      },
    });

    if (!vacation) return false;

    const dateOnly = new Date(date);
    dateOnly.setHours(0, 0, 0, 0);

    return dateOnly >= vacation.startDate && dateOnly <= vacation.endDate;
  }

  /**
   * 매일 자정에 결석 처리
   */
  @Cron('0 0 0 * * *')
  async processAbsences(): Promise<void> {
    this.logger.log('Processing absences for yesterday...');

    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    yesterday.setHours(0, 0, 0, 0);

    const dayOfWeek = yesterday.getDay() || 7;

    const groups = await this.studyGroupRepository.find();

    for (const group of groups) {
      // 어제가 운영일이 아니면 스킵
      if (!group.operatingDays.includes(dayOfWeek.toString())) {
        continue;
      }

      const members = await this.studyMemberRepository.find({
        where: { groupId: group.groupId },
      });

      for (const member of members) {
        // 어제 출퇴근 기록이 없으면 결석 처리
        const record = await this.attendanceRecordRepository.findOne({
          where: {
            groupId: group.groupId,
            studentId: member.studentId,
            date: yesterday,
          },
        });

        if (!record) {
          // 휴가 확인
          const isOnVacation = await this.checkVacation(
            group.groupId,
            member.studentId,
            yesterday,
          );

          const status = isOnVacation ? 'VACATION' : 'ABSENT';
          await this.upsertAttendanceRecord(
            group.groupId,
            member.studentId,
            yesterday,
            {
              status,
              usageMinutes: 0,
              isAutoGenerated: true,
            },
          );

          // 연속성 업데이트
          await this.updateStreakStats(group.groupId, member.studentId, yesterday, status);
        }
      }
    }

    this.logger.log('Absence processing completed');
  }

  // ==================== Helper Methods ====================

  private formatDateForCompare(date: Date): string {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}.${month}.${day}`;
  }

  private getEarliestTime(
    records: LibraryUsageRecord[],
    field: keyof LibraryUsageRecord,
  ): string {
    return records.reduce((earliest, record) => {
      const time = record[field] as string;
      return time < earliest ? time : earliest;
    }, records[0][field] as string);
  }

  private getLatestTime(
    records: LibraryUsageRecord[],
    field: keyof LibraryUsageRecord,
  ): string {
    return records.reduce((latest, record) => {
      const time = record[field] as string;
      return time > latest ? time : latest;
    }, records[0][field] as string);
  }

  private calculateTotalUsageMinutes(records: LibraryUsageRecord[]): number {
    return records.reduce((total, record) => {
      const startMinutes = this.timeToMinutes(record.startTm);
      let endMinutes = this.timeToMinutes(record.endTm);

      // 자정 넘김 처리
      if (endMinutes < startMinutes) {
        endMinutes += 24 * 60;
      }

      return total + (endMinutes - startMinutes);
    }, 0);
  }

  private timeToMinutes(time: string): number {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  }

  /**
   * 수동 출퇴근 동기화 (특정 스터디)
   */
  async manualSync(groupId: string): Promise<void> {
    await this.syncGroupAttendance(groupId);
  }

  /**
   * 특정 멤버의 출석 통계 조회
   */
  async getMemberAttendanceStats(
    groupId: string,
    studentId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{
    totalDays: number;
    presentDays: number;
    lateDays: number;
    earlyLeaveDays: number;
    absentDays: number;
    vacationDays: number;
    attendanceRate: number;
    totalUsageMinutes: number;
  }> {
    const records = await this.attendanceRecordRepository.find({
      where: {
        groupId,
        studentId,
        date: Between(startDate, endDate),
      },
    });

    const presentDays = records.filter((r) => r.status === 'PRESENT').length;
    const lateDays = records.filter((r) => r.status === 'LATE').length;
    const earlyLeaveDays = records.filter(
      (r) => r.status === 'EARLY_LEAVE',
    ).length;
    const absentDays = records.filter((r) => r.status === 'ABSENT').length;
    const vacationDays = records.filter((r) => r.status === 'VACATION').length;

    const totalDays = records.length;
    const attendableDays = totalDays - vacationDays;
    const attendedDays = presentDays + lateDays;
    const attendanceRate =
      attendableDays > 0
        ? Math.round((attendedDays / attendableDays) * 100)
        : 0;

    const totalUsageMinutes = records.reduce(
      (sum, r) => sum + r.usageMinutes,
      0,
    );

    return {
      totalDays,
      presentDays,
      lateDays,
      earlyLeaveDays,
      absentDays,
      vacationDays,
      attendanceRate,
      totalUsageMinutes,
    };
  }

  // ==================== Streak Management Methods ====================

  /**
   * 출석 상태에 따라 연속성 통계 업데이트
   */
  private async updateStreakStats(
    groupId: string,
    studentId: string,
    date: Date,
    status: AttendanceStatus,
  ): Promise<void> {
    const dateOnly = new Date(date);
    dateOnly.setHours(0, 0, 0, 0);

    // 유효한 출석으로 간주되는 상태들 (휴가도 포함)
    const validAttendance = ['PRESENT', 'LATE', 'VACATION'];
    const isValidAttendance = validAttendance.includes(status);

    // 스터디 멤버 연속성 업데이트
    await this.updateStudyMemberStreak(groupId, studentId, dateOnly, isValidAttendance);

    // 전체 사용자 연속성 업데이트
    await this.updateUserOverallStreak(studentId, dateOnly, isValidAttendance);
  }

  /**
   * 스터디별 멤버 연속성 업데이트
   */
  private async updateStudyMemberStreak(
    groupId: string,
    studentId: string,
    date: Date,
    isValidAttendance: boolean,
  ): Promise<void> {
    const member = await this.studyMemberRepository.findOne({
      where: { groupId, studentId },
    });

    if (!member) return;

    const yesterday = new Date(date);
    yesterday.setDate(yesterday.getDate() - 1);

    if (isValidAttendance) {
      // 연속성 증가 또는 시작
      if (!member.lastAttendanceDate) {
        // 첫 출석
        member.currentStreak = 1;
        member.streakStartDate = date;
      } else {
        // 연속성 계산
        const daysDiff = this.getDaysDifference(member.lastAttendanceDate, date);
        if (daysDiff === 1) {
          // 연속 출석
          member.currentStreak += 1;
        } else if (daysDiff > 1) {
          // 연속성 끊어짐
          member.currentStreak = 1;
          member.streakStartDate = date;
        }
        // daysDiff === 0인 경우는 같은 날이므로 변경 없음
      }

      // 최고 기록 업데이트
      if (member.currentStreak > member.longestStreak) {
        member.longestStreak = member.currentStreak;
      }

      member.lastAttendanceDate = date;
    } else {
      // 결석으로 연속성 끊어짐
      member.currentStreak = 0;
      member.streakStartDate = undefined;
    }

    await this.studyMemberRepository.save(member);
  }

  /**
   * 사용자 전체 연속성 업데이트
   */
  private async updateUserOverallStreak(
    studentId: string,
    date: Date,
    isValidAttendance: boolean,
  ): Promise<void> {
    let userStats = await this.userStatsRepository.findOne({
      where: { studentId },
    });

    if (!userStats) {
      // UserStats가 없으면 생성
      userStats = this.userStatsRepository.create({
        studentId,
        totalUsageHours: 0,
        totalSessions: 0,
        totalDays: 0,
        averageSessionHours: 0,
        favoriteRoomVisits: 0,
        favoriteRoomHours: 0,
        weeklyUsageHours: 0,
        weeklySessions: 0,
        weeklyDays: 0,
        tier: 'Explorer',
        isPublicRanking: false,
        currentStreak: 0,
        longestStreak: 0,
      });
    }

    const yesterday = new Date(date);
    yesterday.setDate(yesterday.getDate() - 1);

    if (isValidAttendance) {
      // 연속성 증가 또는 시작
      if (!userStats.lastStudyDate) {
        // 첫 출석
        userStats.currentStreak = 1;
        userStats.streakStartDate = date;
      } else {
        // 연속성 계산
        const daysDiff = this.getDaysDifference(userStats.lastStudyDate, date);
        if (daysDiff === 1) {
          // 연속 출석
          userStats.currentStreak += 1;
        } else if (daysDiff > 1) {
          // 연속성 끊어짐
          userStats.currentStreak = 1;
          userStats.streakStartDate = date;
        }
        // daysDiff === 0인 경우는 같은 날이므로 변경 없음
      }

      // 최고 기록 업데이트
      if (userStats.currentStreak > userStats.longestStreak) {
        userStats.longestStreak = userStats.currentStreak;
      }

      userStats.lastStudyDate = date;
    } else {
      // 결석으로 연속성 끊어짐
      userStats.currentStreak = 0;
      userStats.streakStartDate = undefined;
    }

    await this.userStatsRepository.save(userStats);
  }

  /**
   * 두 날짜 사이의 일수 차이 계산
   */
  private getDaysDifference(date1: Date, date2: Date): number {
    const diffTime = Math.abs(date2.getTime() - date1.getTime());
    return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
  }

  /**
   * 사용자의 연속성 통계 조회
   */
  async getUserStreakStats(studentId: string): Promise<{
    currentStreak: number;
    longestStreak: number;
    streakStartDate?: Date;
    lastStudyDate?: Date;
  }> {
    const userStats = await this.userStatsRepository.findOne({
      where: { studentId },
    });

    if (!userStats) {
      return {
        currentStreak: 0,
        longestStreak: 0,
      };
    }

    return {
      currentStreak: userStats.currentStreak,
      longestStreak: userStats.longestStreak,
      streakStartDate: userStats.streakStartDate,
      lastStudyDate: userStats.lastStudyDate,
    };
  }

  /**
   * 스터디별 멤버 연속성 통계 조회
   */
  async getStudyMemberStreakStats(
    groupId: string,
    studentId: string,
  ): Promise<{
    currentStreak: number;
    longestStreak: number;
    streakStartDate?: Date;
    lastAttendanceDate?: Date;
  }> {
    const member = await this.studyMemberRepository.findOne({
      where: { groupId, studentId },
    });

    if (!member) {
      return {
        currentStreak: 0,
        longestStreak: 0,
      };
    }

    return {
      currentStreak: member.currentStreak,
      longestStreak: member.longestStreak,
      streakStartDate: member.streakStartDate,
      lastAttendanceDate: member.lastAttendanceDate,
    };
  }

  /**
   * 스터디 그룹 내 모든 멤버의 연속성 통계 조회
   */
  async getGroupStreakStats(groupId: string): Promise<Array<{
    studentId: string;
    displayName: string;
    currentStreak: number;
    longestStreak: number;
    streakStartDate?: Date;
    lastAttendanceDate?: Date;
  }>> {
    const members = await this.studyMemberRepository.find({
      where: { groupId },
    });

    return members.map(member => ({
      studentId: member.studentId,
      displayName: member.displayName,
      currentStreak: member.currentStreak,
      longestStreak: member.longestStreak,
      streakStartDate: member.streakStartDate,
      lastAttendanceDate: member.lastAttendanceDate,
    }));
  }

  /**
   * 멤버의 출석 이력 조회 (페이지네이션)
   */
  async getMemberAttendanceHistory(
    groupId: string,
    memberId: string,
    request: MemberAttendanceHistoryRequest
  ): Promise<MemberAttendanceHistoryResponse> {
    const { page = 1, limit = 20, startDate, endDate } = request;

    // 멤버 정보 조회
    const member = await this.studyMemberRepository.findOne({
      where: { memberId, groupId },
    });

    if (!member) {
      throw new Error('멤버를 찾을 수 없습니다.');
    }

    // 날짜 필터 구성
    const whereConditions: any = {
      groupId,
      studentId: member.studentId,
    };

    if (startDate || endDate) {
      const start = startDate ? new Date(startDate) : new Date('1970-01-01');
      const end = endDate ? new Date(endDate) : new Date();
      whereConditions.date = Between(start, end);
    }

    // 총 개수 조회
    const total = await this.attendanceRecordRepository.count({
      where: whereConditions,
    });

    // 페이지네이션된 기록 조회
    const records = await this.attendanceRecordRepository.find({
      where: whereConditions,
      order: { date: 'DESC' },
      skip: (page - 1) * limit,
      take: limit,
    });

    // 통계 계산
    const allRecords = await this.attendanceRecordRepository.find({
      where: whereConditions,
    });

    const summary = this.calculateAttendanceStats(allRecords, groupId);

    // DTO 변환
    const recordDetails: AttendanceRecordDetail[] = records.map(record => ({
      recordId: record.recordId,
      date: record.date.toISOString().split('T')[0],
      checkInTime: record.checkInTime,
      checkOutTime: record.checkOutTime,
      status: record.status,
      usageMinutes: record.usageMinutes,
      note: record.note,
      isAutoGenerated: record.isAutoGenerated,
    }));

    return {
      member: {
        memberId: member.memberId,
        displayName: member.displayName,
      },
      records: recordDetails,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit),
      },
      summary: await summary,
    };
  }

  /**
   * 출석 통계 계산
   */
  private async calculateAttendanceStats(
    records: AttendanceRecord[],
    groupId: string
  ): Promise<AttendanceStats> {
    const studyGroup = await this.studyGroupRepository.findOne({
      where: { groupId },
    });

    if (!studyGroup) {
      throw new Error('스터디 그룹을 찾을 수 없습니다.');
    }

    const totalOperatingDays = records.length;
    const presentDays = records.filter(r => r.status === 'PRESENT').length;
    const lateDays = records.filter(r => r.status === 'LATE').length;
    const earlyLeaveDays = records.filter(r => r.status === 'EARLY_LEAVE').length;
    const absentDays = records.filter(r => r.status === 'ABSENT').length;
    const vacationDays = records.filter(r => r.status === 'VACATION').length;
    
    const attendanceRate = totalOperatingDays > 0 
      ? ((presentDays + lateDays + earlyLeaveDays) / totalOperatingDays) * 100 
      : 0;
    
    const totalUsageMinutes = records.reduce((sum, r) => sum + r.usageMinutes, 0);
    const averageUsageMinutes = totalOperatingDays > 0 
      ? totalUsageMinutes / totalOperatingDays 
      : 0;

    return {
      totalOperatingDays,
      presentDays,
      lateDays,
      earlyLeaveDays,
      absentDays,
      vacationDays,
      attendanceRate: Math.round(attendanceRate * 100) / 100,
      totalUsageMinutes,
      averageUsageMinutes: Math.round(averageUsageMinutes * 100) / 100,
    };
  }

}
